{"entries":[{"timestamp":1748028991860,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"http"],[-1,"s"],[0,"://"],[-1,"developers.google.com/blockly/xml\"><variables></variables><block type=\"device_forever\" id=\"_}x!Q@oREo_=rYj9tPq{\" x=\"0\" y=\"0"],[1,"www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever"],[0,"\"></"]],"start1":12,"start2":12,"length1":135,"length2":102},{"diffs":[[0,"</block>"],[1,"\n"],[0,"</xml>"]],"start1":112,"start2":112,"length1":14,"length2":15}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"basic.forever(function () {\n\t\n})"],[0,"\n"]],"start1":0,"start2":0,"length1":33,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,".md\""],[-1,",\n        \"spikerbit.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"preferredEditor\": \"blocksprj\""],[1,"\n    ],\n    \"additionalFilePaths\": []"],[0,"\n}\n"]],"start1":217,"start2":217,"length1":117,"length2":44}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"},{"type":"added","filename":"spikerbit.ts","value":"// Enums to be used in extension\nenum Signal {\n    EMG,\n    EEG,\n    ECG\n}\n\n\n//% color=\"#FF805E\" icon=\"\\uf188\" weight=90 \nnamespace spikerbit {\n    let buffer: number[] = [];\n    let ecgTimestamps: number[] = [];\n    let signalType: Signal = Signal.EMG\n    let notInitialized = 1\n    let envelopeValue: number = 0\n    let tempCalculationValue: number = 0\n    let lastSample = 0\n    let bpmHeart: number = 0\n    const MAX_BUFFER_SIZE = 750;\n    const NOISE_FLOOR = 580;\n    const ENVELOPE_DECAY = 2;\n    const ECG_TOP_THRESHOLD = 100\n    const ECG_BOTTOM_THRESHOLD = -100\n    const DEBOUNCE_PERIOD_ECG = 300\n    const ECG_LPF_CUTOFF = 40\n    const ECG_HPF_CUTOFF = 3\n\n\n    // Filter notchCoefficients: [b0, b1, b2, a1, a2]\n    let notchCoefficients: number[] = [0, 0, 0, 0, 0];\n    // Buffers to keep the last two input and output samples for Notch\n    let notchInputKeepBuffer: number[] = [0, 0];\n    let notchOutputKeepBuffer: number[] = [0, 0];\n\n    // Lpf Coefficients: [b0, b1, b2, a1, a2]\n    let lpfCoefficients: number[] = [0, 0, 0, 0, 0];\n    // Buffers to keep the last two input and output samples for lpf\n    let lpfInputKeepBuffer: number[] = [0, 0];\n    let lpfOutputKeepBuffer: number[] = [0, 0];\n\n    // Hpf Coefficients: [b0, b1, b2, a1, a2]\n    let hpfCoefficients: number[] = [0, 0, 0, 0, 0];\n    // Buffers to keep the last two input and output samples for lpf\n    let hpfInputKeepBuffer: number[] = [0, 0];\n    let hpfOutputKeepBuffer: number[] = [0, 0];\n\n\n    // Filter parameters\n    const SAMPLING_RATE: number = 250;       // Hz\n    const ALPHA_WAVE_FREQUENCY: number = 10;     // Hz (Notch frequency)\n    const Q_NOTCH: number = 1;                   // Quality factor\n    const Q_LPF_HPF: number = 0.5;                   // Quality factor\n    const BASELINE_ALPHA: number = 20;\n\n    let eegSignalPower: number = 0;\n    let eegNotchedSignalPower: number = 0;\n    let filteredValue: number = 0;\n    let eegAlphaPower: number = 0;\n\n    /**\n     * Calculate intermediate variables and set filter notchCoefficients\n     */\n    function calculateNotchCoefficients(Fc: number, Q: number, Fs: number): void {\n        const omega = (2 * Math.PI * Fc) / Fs;\n        const omegaS = Math.sin(omega);\n        const omegaC = Math.cos(omega);\n        const alpha = omegaS / (2 * Q);\n\n        const a0 = 1 + alpha;\n        const b0 = 1 / a0;\n        const b1 = (-2 * omegaC) / a0;\n        const b2 = 1 / a0;\n        const a1 = (-2 * omegaC) / a0;\n        const a2 = (1 - alpha) / a0;\n\n        // Set the Coefficients array\n        notchCoefficients[0] = b0;\n        notchCoefficients[1] = b1;\n        notchCoefficients[2] = b2;\n        notchCoefficients[3] = a1;\n        notchCoefficients[4] = a2;\n    }\n\n\n    function calculateLPFCoefficients(Fc: number, Q: number, Fs: number): void {\n        const omega = (2 * Math.PI * Fc) / Fs;\n        const omegaS = Math.sin(omega);\n        const omegaC = Math.cos(omega);\n        const alpha = omegaS / (2 * Q);\n\n        const a0 = 1 + alpha;\n        const b0 = ((1 - omegaC) / 2) / a0;\n        const b1 = ((1 - omegaC)) / a0;\n        const b2 = ((1 - omegaC) / 2) / a0;\n        const a1 = (-2 * omegaC) / a0;\n        const a2 = (1 - alpha) / a0;\n\n\n\n        // Set the coefficients array\n        lpfCoefficients[0] = b0;\n        lpfCoefficients[1] = b1;\n        lpfCoefficients[2] = b2;\n        lpfCoefficients[3] = a1;\n        lpfCoefficients[4] = a2;\n    }\n\n\n    function calculateHPFCoefficients(Fc: number, Q: number, Fs: number): void {\n        const omega = (2 * Math.PI * Fc) / Fs;\n        const omegaS = Math.sin(omega);\n        const omegaC = Math.cos(omega);\n        const alpha = omegaS / (2 * Q);\n\n        const a0 = 1 + alpha;\n        const b0 = ((1 + omegaC) / 2) / a0;\n        const b1 = (-1 * (1 + omegaC)) / a0;\n        const b2 = ((1 + omegaC) / 2) / a0;\n        const a1 = (-2 * omegaC) / a0;\n        const a2 = (1 - alpha) / a0;\n\n\n        // Set the coefficients array\n        hpfCoefficients[0] = b0;\n        hpfCoefficients[1] = b1;\n        hpfCoefficients[2] = b2;\n        hpfCoefficients[3] = a1;\n        hpfCoefficients[4] = a2;\n    }\n\n\n    /**\n    * Notch filter a single input sample and return the filtered output\n    * @param inputValue The input sample to be filtered\n    * @returns The filtered output sample\n    */\n    export function notchFilterSingleSample(inputValue: number): number {\n        // Compute the filtered output using the difference equation:\n        // y[n] = b0*x[n] + b1*x[n-1] + b2*x[n-2] - a1*y[n-1] - a2*y[n-2]\n        const y = (notchCoefficients[0] * inputValue) +\n            (notchCoefficients[1] * notchInputKeepBuffer[0]) +\n            (notchCoefficients[2] * notchInputKeepBuffer[1]) -\n            (notchCoefficients[3] * notchOutputKeepBuffer[0]) -\n            (notchCoefficients[4] * notchOutputKeepBuffer[1]);\n\n        // Update the input buffer (shift the samples)\n        notchInputKeepBuffer[1] = notchInputKeepBuffer[0];\n        notchInputKeepBuffer[0] = inputValue;\n\n        // Update the output buffer (shift the samples)\n        notchOutputKeepBuffer[1] = notchOutputKeepBuffer[0];\n        notchOutputKeepBuffer[0] = y;\n\n        return y | 0;\n    }\n\n\n    /**\n    * Low pass Filter a single input sample and return the filtered output\n    * @param inputValue The input sample to be filtered\n    * @returns The filtered output sample\n    */\n    export function lpfFilterSingleSample(inputValue: number): number {\n        // Compute the filtered output using the difference equation:\n        // y[n] = b0*x[n] + b1*x[n-1] + b2*x[n-2] - a1*y[n-1] - a2*y[n-2]\n        const y = (lpfCoefficients[0] * inputValue) +\n            (lpfCoefficients[1] * lpfInputKeepBuffer[0]) +\n            (lpfCoefficients[2] * lpfInputKeepBuffer[1]) -\n            (lpfCoefficients[3] * lpfOutputKeepBuffer[0]) -\n            (lpfCoefficients[4] * lpfOutputKeepBuffer[1]);\n\n        // Update the input buffer (shift the samples)\n        lpfInputKeepBuffer[1] = lpfInputKeepBuffer[0];\n        lpfInputKeepBuffer[0] = inputValue;\n\n        // Update the output buffer (shift the samples)\n        lpfOutputKeepBuffer[1] = lpfOutputKeepBuffer[0];\n        lpfOutputKeepBuffer[0] = y;\n\n        return y | 0;\n    }\n\n\n    /**\n    * High pass Filter a single input sample and return the filtered output\n    * @param inputValue The input sample to be filtered\n    * @returns The filtered output sample\n    */\n    export function hpfFilterSingleSample(inputValue: number): number {\n        // Compute the filtered output using the difference equation:\n        // y[n] = b0*x[n] + b1*x[n-1] + b2*x[n-2] - a1*y[n-1] - a2*y[n-2]\n        const y = (hpfCoefficients[0] * inputValue) +\n            (hpfCoefficients[1] * hpfInputKeepBuffer[0]) +\n            (hpfCoefficients[2] * hpfInputKeepBuffer[1]) -\n            (hpfCoefficients[3] * hpfOutputKeepBuffer[0]) -\n            (hpfCoefficients[4] * hpfOutputKeepBuffer[1]);\n\n        // Update the input buffer (shift the samples)\n        hpfInputKeepBuffer[1] = hpfInputKeepBuffer[0];\n        hpfInputKeepBuffer[0] = inputValue;\n\n        // Update the output buffer (shift the samples)\n        hpfOutputKeepBuffer[1] = hpfOutputKeepBuffer[0];\n        hpfOutputKeepBuffer[0] = y;\n\n        return y | 0;\n    }\n\n    // Define your background function\n    function backgroundTask(): void {\n        while (true) {\n\n            lastSample = tempCalculationValue\n            tempCalculationValue = pins.analogReadPin(AnalogPin.P1)\n            if (signalType == Signal.ECG) {\n                buffer.push(tempCalculationValue);\n\n                if (buffer.length > MAX_BUFFER_SIZE) {\n                    buffer.removeAt(0)\n                }\n\n                tempCalculationValue = lpfFilterSingleSample(tempCalculationValue)\n                tempCalculationValue = hpfFilterSingleSample(tempCalculationValue)\n                if (tempCalculationValue > ECG_TOP_THRESHOLD || tempCalculationValue < ECG_BOTTOM_THRESHOLD) {\n                    let currentMillis = control.millis()\n                    if (ecgTimestamps.length > 0) {\n                        if ((currentMillis - ecgTimestamps[ecgTimestamps.length - 1]) > DEBOUNCE_PERIOD_ECG) {\n                            ecgTimestamps.push(currentMillis)\n                        }\n                    }\n                    else {\n                        ecgTimestamps.push(currentMillis)\n                    }\n\n                    if (ecgTimestamps.length > 3) {\n                        ecgTimestamps.removeAt(0)\n                        bpmHeart = (120000 / (ecgTimestamps[2] - ecgTimestamps[1] + ecgTimestamps[1] - ecgTimestamps[0])) | 0\n\n                    }\n\n                }\n            }\n            else if (signalType == Signal.EMG) {\n                tempCalculationValue = tempCalculationValue - NOISE_FLOOR;\n                if (tempCalculationValue > 0) {\n                    if (tempCalculationValue > envelopeValue) {\n                        envelopeValue = tempCalculationValue;\n                    }\n                }\n\n                envelopeValue = envelopeValue - ENVELOPE_DECAY;\n\n                if (envelopeValue < 0) {\n                    envelopeValue = 0;\n                }\n\n                buffer.push(envelopeValue);\n\n                if (buffer.length > MAX_BUFFER_SIZE) {\n                    buffer.removeAt(0)\n                }\n            }\n            else if (signalType = Signal.EEG) {\n                buffer.push(tempCalculationValue);\n\n                if (buffer.length > MAX_BUFFER_SIZE) {\n                    buffer.removeAt(0)\n                }\n                eegSignalPower = eegSignalPower * 0.99 + 0.01 * (Math.abs(tempCalculationValue - 512))\n                filteredValue = notchFilterSingleSample(tempCalculationValue)\n                eegNotchedSignalPower = eegNotchedSignalPower * 0.99 + 0.01 * (Math.abs(filteredValue - 512))\n                eegAlphaPower = (eegSignalPower - eegNotchedSignalPower) - BASELINE_ALPHA;\n                if (eegAlphaPower < 0) {\n                    eegAlphaPower = 0;\n                }\n            }\n\n            basic.pause(0)\n        }\n    }\n\n\n\n    /**\n     * Start recording EMG signal \n     */\n\n    //% group=\"Muscle\"\n    //% weight=41\n    //% block=\"start muscle recording\"\n    export function startMuscleRecording(): void {\n        signalType = Signal.EMG;\n        pins.digitalWritePin(DigitalPin.P8, 0)\n        pins.digitalWritePin(DigitalPin.P9, 0)\n        if (notInitialized) {\n            control.inBackground(() => {\n                backgroundTask()\n            })\n        }\n    }\n\n    /**\n     * Return last envelope value\n     */\n\n    //% group=\"Muscle\"\n    //% weight=40\n    //% block=\"muscle power signal\"\n    export function musclePowerSignal(): number {\n        if (signalType == Signal.EMG) {\n            return envelopeValue;\n        }\n        else {\n            return 0;\n        }\n    }\n\n    /**\n     * Start recording ECG signal\n     */\n\n    //% group=\"Heart\"\n    //% weight=52\n    //% block=\"start heart recording\"\n    export function startHeartRecording(): void {\n        signalType = Signal.ECG;\n        calculateLPFCoefficients(ECG_LPF_CUTOFF, Q_LPF_HPF, SAMPLING_RATE)\n        calculateHPFCoefficients(ECG_HPF_CUTOFF, Q_LPF_HPF, SAMPLING_RATE);\n        pins.digitalWritePin(DigitalPin.P8, 1)\n        pins.digitalWritePin(DigitalPin.P9, 0)\n        if (notInitialized) {\n            control.inBackground(() => {\n                backgroundTask()\n            })\n        }\n    }\n\n\n\n    /**\n     * Return last measured value of the ECG signal\n     */\n\n    //% group=\"Heart\"\n    //% weight=51\n    //% block=\"heart signal\"\n    export function heartSignal(): number {\n        if (buffer.length > 0 && signalType == Signal.ECG) {\n            return buffer[buffer.length - 1];\n        }\n        else {\n            return 0;\n        }\n    }\n\n    /**\n     * Return heart rate\n     */\n\n    //% group=\"Heart\"\n    //% weight=50\n    //% block=\"heart rate\"\n    export function heartRate(): number {\n        if (signalType == Signal.ECG) {\n            return bpmHeart;\n        }\n        else {\n            return 0;\n        }\n    }\n\n    /**\n     * Start recording EEG signal\n     */\n\n    //% group=\"Brain\"\n    //% weight=62\n    //% block=\"start brain recording\"\n    export function startBrainRecording(): void {\n        signalType = Signal.EEG;\n        calculateNotchCoefficients(ALPHA_WAVE_FREQUENCY, Q_NOTCH, SAMPLING_RATE);\n        pins.digitalWritePin(DigitalPin.P8, 0)\n        pins.digitalWritePin(DigitalPin.P9, 1)\n        if (notInitialized) {\n            control.inBackground(() => {\n                backgroundTask()\n            })\n        }\n    }\n\n    /**\n     * Return last measured value of the EEG signal\n     */\n\n    //% group=\"Brain\"\n    //% weight=61\n    //% block=\"brain signal\"\n    export function brainSignal(): number {\n        if (buffer.length > 0 && signalType == Signal.EEG) {\n            return buffer[buffer.length - 1];\n        }\n        else {\n            return 0;\n        }\n    }\n\n    /**\n         * Return alpha waves power\n         */\n\n    //% group=\"Brain\"\n    //% weight=60\n    //% block=\"brain alpha power\"\n    export function brainAlphaPower(): number {\n        if (signalType == Signal.EEG) {\n            return eegAlphaPower;\n        }\n        else {\n            return 0;\n        }\n    }\n\n\n    /**\n     * Print number provided as input parameter\n     */\n\n    //% group=\"Helper Utility\"\n    //% weight=74\n    //% block=\"print %value\"\n    export function print(value: number): void {\n        serial.writeValue(\"Signal\", value);\n    }\n\n\n    /**\n     * Return tree seconds of recorded signal\n     */\n\n    //% group=\"Helper Utility\"\n    //% weight=73\n    //% block=\"signal block || in last $durationMs (ms)\"\n    //% durationMs.defl = 3000\n    export function signalBlock(durationMs?: number): number[] {\n        control.assert(durationMs >= 0 || durationMs <= 3000, \"Spikerbit error\")\n\n        // Calculate number of samples\n        let numSamples = Math.floor(durationMs / 4);\n\n        // Get only the first `numSamples` elements from `buffer`\n        const bufferSlice = buffer.slice(Math.max(buffer.length - numSamples, 0));\n\n        return bufferSlice;\n    }\n\n\n    /**\n     * Returns max value of signal for the specified duration in milliseconds.\n     * Uses an internal buffer sampled at 250 Hz. \n     */\n\n    //% group=\"Helper Utility\"\n    //% weight=72\n    //% block=\"max signal in last $durationMs ms\"\n    export function maxSignalInLast(durationMs: number): number {\n\n        let numSamples = Math.floor(durationMs / 4);  // Calculate number of samples\n\n        // Get only the first `numSamples` elements from `buffer`\n        const bufferSlice = buffer.slice(Math.max(buffer.length - numSamples, 0));\n\n        // Calculate the max value in this slice\n        return bufferSlice.reduce((max, current) => current > max ? current : max, -Infinity);\n    }\n\n\n\n    /**\n     * Returns number of peaks of signal for the specified duration in milliseconds.\n     * Uses an internal buffer sampled at 250 Hz.\n     */\n\n    //% group=\"Helper Utility\"\n    //% weight=71\n    //% block=\"number of peaks in last $durationMs ms\"\n    export function numPeaksInLast(durationMs: number): number {\n\n        // Get only the first `numSamples` elements from `buffer`\n        const numSamples = Math.floor(durationMs / 4);  // Calculate number of samples\n        const bufferSlice = buffer.slice(Math.max(buffer.length - numSamples, 0));\n\n        let baseline = 0;\n        let prevValue = -Infinity;\n        let rising = false;\n        let peak = -1;\n        let steps = 20;\n        let counter = 0;\n\n        for (let value of bufferSlice) {\n\n            // The singal is in the rising phase\n            if (value > prevValue) {\n                rising = true;\n                peak = -1;\n            } else {\n                // Check ONLY IF rising happened before falling\n                if (rising) {\n\n                    // Get the peak point\n                    if (peak == -1) {\n                        peak = prevValue;\n                    }\n\n                    // Increase the counter ONLY IF current signal is \n                    // 'ENVELOPE_DECAY' * 'steps' away from the peak\n                    if (peak - value > ENVELOPE_DECAY * steps) {\n                        counter++;\n                        rising = false;\n                    }\n                }\n            }\n\n            // Update the previous signal\n            prevValue = value;\n        }\n\n        return counter;\n\n    }\n\n}"}]}],"snapshots":[{"timestamp":1748028991859,"editorVersion":"7.0.61","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"v1.0.0\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1748029096578}